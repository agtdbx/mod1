#version 430 core

layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

layout(r32f, binding = 0) uniform imageBuffer mapPressuresAcceleration;
layout(std430, binding = 2) readonly buffer DataBuffer {
	int gridBuffer[];
};

uniform float			smoothingRadius;
uniform float			smoothingDerivateScale;
uniform float			waterMass;
uniform float			pressureMultiplier;
uniform int				mapBufferCellSize;
uniform int				mapBufferW;
uniform int				mapBufferIdHsize;
uniform int				mapBufferSize;
uniform int				gridW;
uniform int				gridH;
uniform int				gridD;
uniform int				idHsize;
uniform int				gridSize;
uniform samplerBuffer	positionsBuffer;
uniform samplerBuffer	mapDensitiesBuffer;
uniform samplerBuffer	mapPressuresBuffer;


float	vecLength(vec3 vec)
{
	return (sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z));
}


float	smoothingKernelDerivate(float dst)
{
	if (dst > smoothingRadius)
		return (0.0);

	return ((dst - smoothingRadius) * smoothingDerivateScale);
}


float	calculateSharedPressure(float pressureA, float pressureB)
{
	return ((pressureA + pressureB) / 2.0);
}


vec3	calculatePressureForce(vec3 position, float density, float pressure)
{
	float	densityWater, pressureWater,
			dst, slope, sharedPressure;
	int		px, py, pz, gx, gy, gz, gid, nbParticleInCell, waterId;
	vec3	pressureForce, positionWater, dir;

	pressureForce = vec3(0.0, 0.0, 0.0);

	px = int(position.x / smoothingRadius);
	py = int(position.y / smoothingRadius);
	pz = int(position.z / smoothingRadius);

	for (int cx = -1; cx <= 1; cx++)
	{
		gx = px + cx;
		if (gx < 0 || gx >= gridW)
			continue;

		for (int cy = -1; cy <= 1; cy++)
		{
			gy = py + cy;
			if (gy < 0 || gy >= gridH)
				continue;

			for (int cz = -1; cz <= 1; cz++)
			{
				gz = pz + cz;
				if (gz < 0 || gz >= gridD)
					continue;

				gid = gx + gz * gridW + gy * idHsize;
				nbParticleInCell = gridBuffer[gid];
				for (int i = 0; i < nbParticleInCell; i++)
				{
					gid += gridSize;
					waterId = gridBuffer[gid];
					positionWater = texelFetch(predictedPositionsBuffer, waterId).rgb;
					pressureWater = texelFetch(pressuresBuffer, waterId).r;

					dir = positionWater - position;
					dst = vecLength(dir);
					if (dst == 0.0)
						dir = vec3(0.0, 1.0, 0.0);
					else
						dir /= dst;
					slope = smoothingKernelDerivate(dst);
					sharedPressure = calculateSharedPressure(pressure, pressureWater);
					pressureForce += sharedPressure * dir * slope;
				}
			}
		}
	}

	return (pressureForce * waterMass / density);
}


void main()
{
	int		cellIndex, idXZ, x, y, z;
	float	density, pressure;
	vec3	position, pressureForce, pressureAcceleration;

	// Check cell index
	cellIndex = int(gl_GlobalInvocationID.x);
	if (cellIndex >= mapBufferSize)
		return ;

	// If density is null, stop here
	density = texelFetch(mapDensitiesBuffer, cellIndex).r;
	if (density == 0.0)
	{
		imageStore(mapPressuresAcceleration, cellIndex, vec4(0.0, 0.0, 0.0, 1.0));
		return ;
	}

	// Compute cell x y z in grid
	y = int(cellIndex / mapBufferIdHsize);
	idXZ = cellIndex - (y * mapBufferIdHsize);
	z = int(idXZ / mapBufferW);
	x = idXZ - (z * mapBufferW);

	// Get precompute values
	position = vec3(x, y, z) * mapBufferCellSize;
	pressure = texelFetch(mapPressuresBuffer, cellIndex).r;

	// Computre pressure acceleration
	pressureForce = calculatePressureForce(position);
	pressureAcceleration = pressureForce / density;

	// Write the values to the buffers
	imageStore(mapPressuresAcceleration, cellIndex, vec4(pressureAcceleration, 1.0));
}
