#version 430 core

layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform imageBuffer predictedPositionBuffer;
layout(rgba32f, binding = 1) uniform imageBuffer velocitiesBuffer;

uniform	float			delta;
uniform float			waterRadius;
uniform float			waterMaxXZ;
uniform float			waterMaxY;
uniform float			gravityForce;
uniform int				positionsSize;
uniform samplerBuffer	positionsBuffer;

void main()
{
	int		particleIndex;
	vec3	position, velocity, predictedPosition;

	particleIndex = int(gl_GlobalInvocationID.x);
	if (particleIndex >= positionsSize)
		return ;

	position = texelFetch(positionsBuffer, particleIndex).rgb;
	velocity = imageLoad(velocitiesBuffer, particleIndex).rgb;
	velocity += vec3(0.0, -gravityForce, 0.0) * delta;
	predictedPosition = position + velocity * delta;

	// Check if particule is out of the map on x axis
	if (predictedPosition.x < waterRadius)
		predictedPosition.x = waterRadius;
	else if (predictedPosition.x >= waterMaxXZ)
		predictedPosition.x = waterMaxXZ;

	// Check if particule is out of the map on y axis
	if (predictedPosition.y < waterRadius)
		predictedPosition.y = waterRadius;
	else if (predictedPosition.y >= waterMaxY)
		predictedPosition.y = waterMaxY;

	// Check if particule is out of the map on z axis
	if (predictedPosition.z < waterRadius)
		predictedPosition.z = waterRadius;
	else if (predictedPosition.z >= waterMaxXZ)
		predictedPosition.z = waterMaxXZ;

	// Write the value to the buffer
	imageStore(predictedPositionBuffer, particleIndex, vec4(predictedPosition, 1.0));
	imageStore(velocitiesBuffer, particleIndex, vec4(velocity, 1.0));
}
