#version 430 core

layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform imageBuffer velocitiesBuffer;

uniform float			delta;
uniform float			smoothingRadius;
uniform float			smoothingDerivateScale;
uniform float			smoothingViscosityScale;
uniform float			waterMass;
uniform float			waterRadius2;
uniform float			targetDensity;
uniform float			pressureMultiplier;
uniform float			viscosityStrength;
uniform int				gridW;
uniform int				gridH;
uniform int				gridD;
uniform int				idHsize;
uniform int				gridSize;
uniform samplerBuffer	gridBuffer;
uniform int				offsetsSize;
uniform samplerBuffer	offsetsBuffer;
uniform samplerBuffer	predictedPositionsBuffer;
uniform samplerBuffer	densitiesBuffer;

float	vecLength(vec3 vec)
{
	return (sqrt(vec.x * vec.x + vec.y * vec.y + vec.z * vec.z));
}


float	smoothingKernelDerivate(float dst)
{
	if (dst > smoothingRadius)
		return (0.0);

	return ((dst - smoothingRadius) * smoothingDerivateScale);
}


float	viscositySmoothingKernel(float dst)
{
	float	value;

	if (dst > smoothingRadius)
		return (0.0);

	value = waterRadius2 - (dst * dst);
	return ((value * value * value) * smoothingViscosityScale);
}


float	convertDensityToPressure(float density)
{
	return ((density - targetDensity) * pressureMultiplier);
}


float	calculateSharedPressure(float densityA, float densityB)
{
	float	pressureA, pressureB;

	pressureA = convertDensityToPressure(densityA);
	pressureB = convertDensityToPressure(densityB);

	return ((pressureA + pressureB) / 2.0);
}


vec3	calculatePressureForce(int particleIndex)
{
	float	density, densityWater, dst, slope, sharedPressure;
	int		px, py, pz, gx, gy, gz, gid, startId, endId, waterId;
	vec3	pressureForce, position, positionWater, dir;

	pressureForce = vec3(0.0, 0.0, 0.0);

	position = texelFetch(predictedPositionsBuffer, particleIndex).rgb;
	density = texelFetch(densitiesBuffer, particleIndex).r;
	px = int(position.x / smoothingRadius);
	py = int(position.y / smoothingRadius);
	pz = int(position.z / smoothingRadius);

	for (int cx = -1; cx <= 1; cx++)
	{
		gx = px + cx;
		if (gx < 0 || gx >= gridW)
			continue;

		for (int cy = -1; cy <= 1; cy++)
		{
			gy = py + cy;
			if (gy < 0 || gy >= gridH)
				continue;

			for (int cz = -1; cz <= 1; cz++)
			{
				gz = pz + cz;
				if (gz < 0 || gz >= gridD)
					continue;

				gid = gx + gz * gridW + gy * idHsize;
				startId = int(texelFetch(offsetsBuffer, gid).r);
				if (gid + 1 < offsetsSize)
					endId = int(texelFetch(offsetsBuffer, gid + 1).r);
				else
					endId = gridSize;

				for (int i = startId; i < endId; i++)
				{
					waterId = int(texelFetch(gridBuffer, i).r);
					if (waterId == particleIndex)
						continue;

					positionWater = texelFetch(predictedPositionsBuffer, waterId).rgb;
					densityWater = texelFetch(densitiesBuffer, waterId).r;

					dir = positionWater - position;
					dst = vecLength(dir);
					if (dst == 0.0)
						dir = vec3(0.0, 1.0, 0.0);
					else
						dir /= dst;
					slope = smoothingKernelDerivate(dst);
					sharedPressure = calculateSharedPressure(density, densityWater);
					pressureForce += sharedPressure * dir * slope * waterMass / density;
				}
			}
		}
	}

	return (pressureForce);
}

vec3	calculateViscosityForce(int particleIndex)
{
	float	velocityLength, dst, influence;
	int		px, py, pz, gx, gy, gz, gid, startId, endId, waterId;
	vec3	viscosityForce, position, positionWater, velocity, velocityWater, velocityDir;

	viscosityForce = vec3(0.0, 0.0, 0.0);

	position = texelFetch(predictedPositionsBuffer, particleIndex).rgb;
	velocity = imageLoad(velocitiesBuffer, particleIndex).rgb;
	px = int(position.x / smoothingRadius);
	py = int(position.y / smoothingRadius);
	pz = int(position.z / smoothingRadius);

	for (int cx = -1; cx <= 1; cx++)
	{
		gx = px + cx;
		if (gx < 0 || gx >= gridW)
			continue;

		for (int cy = -1; cy <= 1; cy++)
		{
			gy = py + cy;
			if (gy < 0 || gy >= gridH)
				continue;

			for (int cz = -1; cz <= 1; cz++)
			{
				gz = pz + cz;
				if (gz < 0 || gz >= gridD)
					continue;

				gid = gx + gz * gridW + gy * idHsize;
				startId = int(texelFetch(offsetsBuffer, gid).r);
				if (gid + 1 < offsetsSize)
					endId = int(texelFetch(offsetsBuffer, gid + 1).r);
				else
					endId = gridSize;

				for (int i = startId; i < endId; i++)
				{
					waterId = int(texelFetch(gridBuffer, i).r);
					if (waterId == particleIndex)
						continue;

					positionWater = texelFetch(predictedPositionsBuffer, waterId).rgb;
					velocityWater = imageLoad(velocitiesBuffer, waterId).rgb;

					// velocityDir = velocityWater - velocity;
					// velocityLength = vecLength(velocityDir);
					// if (velocityLength == 0.0)
					// 	continue;

					// velocityDir /= velocityLength;
					// dst = vecLength(position - positionWater);
					// influence = viscositySmoothingKernel(dst);
					// viscosityForce += velocityDir * influence;

					velocityDir = velocityWater - velocity;
					dst = vecLength(position - positionWater);
					influence = viscositySmoothingKernel(dst);
					viscosityForce += velocityDir * influence;
				}
			}
		}
	}

	return (viscosityForce * viscosityStrength);
}

void main()
{
	int		particleIndex;
	float	density;
	vec3	velocity, pressureForce, pressureAcceleration, viscosityForce;

	particleIndex = int(gl_GlobalInvocationID.x);
	velocity = imageLoad(velocitiesBuffer, particleIndex).rgb;
	density = texelFetch(densitiesBuffer, particleIndex).r;

	if (density != 0.0)
	{
		pressureForce = calculatePressureForce(particleIndex);
		pressureAcceleration = pressureForce / density;
		velocity += pressureAcceleration * delta;

		viscosityForce = calculateViscosityForce(particleIndex);
		velocity += viscosityForce * delta;
	}
	else
		velocity = vec3(0.0, 0.0, 0.0);

	// Write the value to the buffer
	imageStore(velocitiesBuffer, particleIndex, vec4(velocity, 1.0));
}
