#version 430 core

layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform imageBuffer positionsBuffer;
layout(rgba32f, binding = 1) uniform imageBuffer velocitiesBuffer;

uniform bool			holeEnable;
uniform float			holeRadius2;
uniform vec2			holePosition;
uniform	float			delta;
uniform float			waterRadius;
uniform float			waterMaxXZ;
uniform float			waterMaxY;
uniform float			collisionEnergyKeep;
uniform float			collisionRepulsionForce;
uniform float			invTerrainCellSize;
uniform int				terrainGridW;
uniform int				terrainGridH;
uniform int				terrainGridD;
uniform int				terrainIdHsize;
uniform int				terrainGridSize;
uniform int				terrainOffsetsSize;
uniform int				positionsSize;
uniform samplerBuffer	terrainDataBuffer;
uniform samplerBuffer	terrainGridBuffer;
uniform samplerBuffer	terrainOffsetsBuffer;


float	vecLength(vec3 vec)
{
	return sqrt((vec.x * vec.x + vec.y * vec.y + vec.z * vec.z));
}


int	checkCollisionWithTerrain(vec3 position)
{
	int	px, py, pz, gx, gy, gz, gid, startId, endId, rectangleId;
	vec3	rectPos, vecX, vecZ, posFromRect, posOnRect;
	float	minY, maxY, a, b;

	px = int(position.x * invTerrainCellSize);
	py = int(position.y * invTerrainCellSize);
	pz = int(position.z * invTerrainCellSize);

	for (int cx = -1; cx < 2; cx++)
	{
		gx = px + cx;
		if (gx < 0 || gx >= terrainGridW)
			continue;

		for (int cy = -1; cy < 2; cy++)
		{
			gy = py + cy;
			if (gy < 0 || gy >= terrainGridH)
				continue;

			for (int cz = -1; cz < 2; cz++)
			{
				gz = pz + cz;
				if (gz < 0 || gz >= terrainGridD)
					continue;

				gid = gx + gz * terrainGridW + gy * terrainIdHsize;
					startId = int(texelFetch(terrainOffsetsBuffer, gid).r);
				if (gid + 1 < terrainOffsetsSize)
					endId = int(texelFetch(terrainOffsetsBuffer, gid + 1).r);
				else
					endId = terrainGridSize;

				for (int i = startId; i < endId; i++)
				{
					rectangleId = int(texelFetch(terrainGridBuffer, i).r);
					rectPos = texelFetch(terrainDataBuffer, rectangleId * 5).rgb;
					vecX = texelFetch(terrainDataBuffer, rectangleId * 5 + 1).rgb;
					vecZ = texelFetch(terrainDataBuffer, rectangleId * 5 + 2).rgb;

					posFromRect = position - rectPos;
					minY = min(vecX.y, vecZ.y);
					maxY = max(vecX.y, vecZ.y);

					if (posFromRect.x < -waterRadius || posFromRect.x > vecX.x
						|| posFromRect.y < minY - waterRadius || posFromRect.y > maxY + waterRadius
						|| posFromRect.z < -waterRadius || posFromRect.z > vecZ.z)
						continue;

					if (vecX.x != 0.0)
						a = posFromRect.x / vecX.x;
					else if (vecX.y != 0.0)
						a = posFromRect.y / vecX.y;
					else
						continue;

					if (vecZ.z != 0.0)
						b = posFromRect.z / vecZ.z;
					else if (vecZ.y != 0.0)
						b = posFromRect.y / vecZ.y;
					else
						continue;

					posOnRect = rectPos + a * vecX + b * vecZ;

					if (posFromRect.y - waterRadius > posOnRect.y)
						continue;

					return (rectangleId);
				}
			}
		}
	}

	return (-1);
}


void main()
{
	int		particleIndex, terrainCollisionId;
	float	velocityLength, holeDst2;
	vec2	holeDir;
	vec3	position, velocity, newPosition, velocityDir, normal;
	bool	needUpdateVelocity, skipCollisionLoose;

	particleIndex = int(gl_GlobalInvocationID.x);
	if (particleIndex >= positionsSize)
		return ;

	velocity = imageLoad(velocitiesBuffer, particleIndex).rgb;
	position = imageLoad(positionsBuffer, particleIndex).rgb;
	newPosition = position + velocity * delta;
	needUpdateVelocity = false;
	skipCollisionLoose = false;

	// Check terrain collision
	terrainCollisionId = checkCollisionWithTerrain(newPosition);

	// Make particule bounce in case of collision
	if (terrainCollisionId != -1)
	{
		velocityLength = vecLength(velocity);
		if (velocityLength != 0.0)
		{
			velocityDir = velocity / velocityLength;
			if (velocityLength < 5.0 && velocityLength > 0.5)
				skipCollisionLoose = true;

			normal = texelFetch(terrainDataBuffer, terrainCollisionId * 5 + 4).rgb;
			velocityDir -= normal * 2 * dot(velocityDir, normal);
			velocityDir = normalize(velocityDir);
			velocity = velocityDir * velocityLength;

			newPosition = position + velocity * delta;
			needUpdateVelocity = true;
		}
	}

	// Check if particule is out of the map on x axis
	if (newPosition.x < waterRadius)
	{
		newPosition.x = waterRadius + collisionRepulsionForce;
		velocity.x *= -1.0;
		needUpdateVelocity = true;
	}
	else if (newPosition.x >= waterMaxXZ)
	{
		newPosition.x = waterMaxXZ - collisionRepulsionForce;
		velocity.x *= -1.0;
		needUpdateVelocity = true;
	}

	// Check if particule is out of the map on y axis
	if (newPosition.y < waterRadius)
	{
		if (holeEnable)
		{
			holeDir = holePosition - vec2(newPosition.x, newPosition.z);
			holeDst2 = holeDir.x * holeDir.x + holeDir.y * holeDir.y;
			if (holeDst2 > holeRadius2)
			{
				newPosition.y = waterRadius;
				velocity.y *= -1.0;
				needUpdateVelocity = true;
			}
			else
			{
				if (newPosition.y < -3.0)
				{
					newPosition.y = -3.0;
					velocity *= vec3(0.0, 0.0, 0.0);
					needUpdateVelocity = true;
				}
			}
		}
		else
		{
			newPosition.y = waterRadius + collisionRepulsionForce;
			velocity.y *= -1.0;
			needUpdateVelocity = true;
		}
	}
	else if (newPosition.y >= waterMaxY)
	{
		newPosition.y = waterMaxY - collisionRepulsionForce;
		velocity.y *= -1.0;
		needUpdateVelocity = true;
	}

	// Check if particule is out of the map on z axis
	if (newPosition.z < waterRadius)
	{
		newPosition.z = waterRadius + collisionRepulsionForce;
		velocity.z *= -1.0;
		needUpdateVelocity = true;
	}
	else if (newPosition.z >= waterMaxXZ)
	{
		newPosition.z = waterMaxXZ - collisionRepulsionForce;
		velocity.z *= -1.0;
		needUpdateVelocity = true;
	}

	// Update density if needed
	if (needUpdateVelocity)
	{
		if (!skipCollisionLoose)
			velocity *= collisionEnergyKeep;
		imageStore(velocitiesBuffer, particleIndex, vec4(velocity, 1.0));
	}

	// Write the value to the buffer
	imageStore(positionsBuffer, particleIndex, vec4(newPosition, 1.0));
}
