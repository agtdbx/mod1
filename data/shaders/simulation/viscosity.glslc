#version 430 core

layout (local_size_x = 8, local_size_y = 1, local_size_z = 1) in;

layout(rgba32f, binding = 0) uniform imageBuffer velocitiesBuffer;
layout(std430, binding = 1) readonly buffer DataBuffer {
	int gridBuffer[];
};

uniform float			delta;
uniform int				positionsSize;
uniform samplerBuffer	positionsBuffer;
uniform samplerBuffer	densitiesBuffer;

uniform int				mapBufferCellSize;
uniform int				mapBufferW;
uniform int				mapBufferH;
uniform int				mapBufferD;
uniform int				mapBufferIdHsize;
uniform samplerBuffer	mapViscositiesBuffer;


// interpolate function
vec3	getViscosityAtMapPoint(int x, int y, int z)
{
	if (x >= mapBufferW || y >= mapBufferH || z >= mapBufferD)
		return (vec3(0.0, 0.0, 0.0));

	int	tid = x + z * mapBufferW + y * mapBufferIdHsize;
	vec3 viscosity = texelFetch(mapViscositiesBuffer, tid).rgb;
	return (viscosity);
}


vec3	lerp(vec3 start, vec3 end, float ratio)
{
	return (start + (end - start) * ratio);
}


vec3	getViscosityAtPos(vec3 pos)
{
	int		gx, gy, gz, ngx, ngy, ngz;
	vec3	viscosityFUL, viscosityFUR, viscosityFDL, viscosityFDR,
			viscosityBUL, viscosityBUR, viscosityBDL, viscosityBDR,
			viscosityFU, viscosityFD, viscosityBU, viscosityBD,
			viscosityF, viscosityB,
			viscosity;
	float	dx, dy, dz, invMapBufferCellSize;

	if (mapBufferCellSize == 0.0)
		return (vec3(0.0, 0.0, 0.0));
	invMapBufferCellSize = 1.0 / mapBufferCellSize;

	// Get grid coordonates
	gx = int(pos.x * invMapBufferCellSize);
	gy = int(pos.y * invMapBufferCellSize);
	gz = int(pos.z * invMapBufferCellSize);
	ngx = gx + 1;
	ngy = gy + 1;
	ngz = gz + 1;

	// Get ratio for each axis
	dx = (pos.x - (gx * mapBufferCellSize)) * invMapBufferCellSize;
	dy = (pos.y - (gy * mapBufferCellSize)) * invMapBufferCellSize;
	dz = (pos.z - (gz * mapBufferCellSize)) * invMapBufferCellSize;

	// Get viscosity for 8 cell around pos
	viscosityFUL = getViscosityAtMapPoint(gx,  gy,  gz);
	viscosityFUR = getViscosityAtMapPoint(ngx, gy,  gz);
	viscosityFDL = getViscosityAtMapPoint(gx,  ngy, gz);
	viscosityFDR = getViscosityAtMapPoint(ngx, ngy, gz);
	viscosityBUL = getViscosityAtMapPoint(gx,  gy,  ngz);
	viscosityBUR = getViscosityAtMapPoint(ngx, gy,  ngz);
	viscosityBDL = getViscosityAtMapPoint(gx,  ngy, ngz);
	viscosityBDR = getViscosityAtMapPoint(ngx, ngy, ngz);

	// Merge viscosity on x axis
	viscosityFU = lerp(viscosityFUL, viscosityFUR, dx);
	viscosityFD = lerp(viscosityFDL, viscosityFDR, dx);
	viscosityBU = lerp(viscosityBUL, viscosityBUR, dx);
	viscosityBD = lerp(viscosityBDL, viscosityBDR, dx);

	// Merge viscosity on y axis
	viscosityF = lerp(viscosityFU, viscosityFD, dy);
	viscosityB = lerp(viscosityBU, viscosityBD, dy);

	// Merge viscosity on z axis
	viscosity = lerp(viscosityF, viscosityB, dz);
	return (viscosity);
}


void main()
{
	int		particleIndex;
	float	density;
	vec3	position, velocity, viscosityForce;

	particleIndex = int(gl_GlobalInvocationID.x);
	if (particleIndex >= positionsSize)
		return ;

	density = texelFetch(densitiesBuffer, particleIndex).r;

	if (density != 0.0)
	{
		position = texelFetch(positionsBuffer, particleIndex).rgb;
		velocity = imageLoad(velocitiesBuffer, particleIndex).rgb;
		// viscosityForce = calculateViscosityForce(particleIndex);
		viscosityForce = getViscosityAtPos(position);
		velocity += viscosityForce * delta;
	}
	else
		velocity = vec3(0.0, 0.0, 0.0);

	// Write the value to the buffer
	imageStore(velocitiesBuffer, particleIndex, vec4(velocity, 1.0));
}
